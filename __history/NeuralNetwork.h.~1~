
class NeuralNetwork{
	private:

  Neuron **neuro_net_array;
  int n_of_layers;
  int *n_of_neurons_in_layers;

	public:

  NeuralNetwork(int*, int);
  int getNumberOfLayers(){return n_of_layers;};
  int getNumberOfNeuronsInLayer(layer_number){return n_of_neurons_in_layers[layer_number];};
  void LearnEpoch(int *inputdata, int result, TMemo* logMemo);
};

NeuralNetwork::NeuralNetwork(int* n_of_neurons_in_each_layer, int number_of_layers){
  n_of_layers = number_of_layers;
  n_of_neurons_in_layers = new int[n_of_layers];

  for (int i = 0; i < n_of_layers; i++) {
	n_of_neurons_in_layers[i] = n_of_neurons_in_each_layer[i];
  }

  neuro_net_array = new Neuron*[n_of_layers];
  for (int i = 0 ; i < n_of_layers; i++) {
	neuro_net_array[i] = new Neuron[n_of_neurons_in_layers[i]];
  }
  // int mode; //input, output, hidden = 1,2,3
  //int function; //sigmoid, por = 1,2
  for (int i = 0; i < n_of_layers; i++) {
	for (int j = 0; j<n_of_neurons_in_layers[i]; j++) {
	  int mode;
	  int function;
	  if (i == 0) {
		mode = 1;
		function = 1
	  }else if ( i == n_of_layers-1){
		mode = 2;
		function = 2;
	  }else{
		mode = 3;
		function = 1;
	  }
	  neuro_net_array[i][j] = *(new Neuron(i, j, mode, function));
	}
  }
}

void NeuralNetwork::LearnEpoch(int* inputdata, int result, TMemo* logMemo){
	for(int i = 0; i < n_of_layers; i++){
		for (int j = 0; j < n_of_neurons_in_layers[i]; j++) {
			Neuron neuron = neuro_net_array[i][j];
			logMemo->Lines->Add("Neuron["+AnsiString(i)+"]["+AnsiString(j)+"] Mode:"+AnsiString(neuron.getMode()));
			if(neuron.getMode() == 1){
				neuron.setNet(inputdata[j]);
			}else{
				neuron.calculate_net();
			}
			logMemo->Lines->Add(" network value -> "+AnsiString(neuron.getNet()));
			neuron.active_function();
			logMemo->Lines->Add(" active signal -> "+AnsiString(neuron.getActiveSignal()));

		}
	}
}






